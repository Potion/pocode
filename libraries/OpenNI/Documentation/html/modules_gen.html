<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.4.0: Implemeting a Generator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('modules_gen.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>Implemeting a Generator </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>If our node implementation is some sort of generator (i.e. produces data), it can be usually implemeted in one of two ways - an active generator (i.e. generates data in the background somehow) or a passive one (i.e. processes other nodes data in order to create new data). While those two models are different when implementing, they both fit in OpenNI interfaces.</p>
<p>When a generator has new data, it informs OpenNI by raising its <em>New Data Available</em> event. This will cause OpenNI to call its <a class="el" href="classxn_1_1_module_generator.html#a543e11766a86916c78d7065d0f4bb4a8">xn::ModuleGenerator::UpdateData()</a> method in the application main-loop (assuming the application is using one of the <em>WaitXUpdateAll</em> methods. The UpdateData method is the only place where the node implementation is allowed to change its <em>Last Updated Data</em>. This flow is explained in details in the following sections.</p>
<h2><a class="anchor" id="modules_gen_state"></a>
The Generating State</h2>
<p>A generator can be in one of two states: generating and non-generating. When the node is created, it is in the non-generating state. This state is useful for choosing configuration before actually starting to generate new data.</p>
<p>A generator's state can be changed to generating by calling its <a class="el" href="classxn_1_1_module_generator.html#a85a3020712a333d3b36a6af137995b40">xn::ModuleGenerator::StartGenerating()</a> method, and can be changed to non-generating by calling its <a class="el" href="classxn_1_1_module_generator.html#a58c065a0b750e8680fb294eedddc6a2c">xn::ModuleGenerator::StopGenerating()</a> method. The generator is responsible to raise the "Generation Running Changed" event whenever its generating state is changed.</p>
<p>In essense, when in the generating state, the generator constantly generates new data (unless bounded by some input of course).</p>
<h2><a class="anchor" id="modules_gen_new"></a>
New Data</h2>
<p>When a generator is in the generating state it generates "new" data, meaning, data that the application hasn't received yet. A generator does not simply replace its data when it can. Each generator is responsible of holding the last data that the application received, and not to modify it. Instead, when new data is available, the generator should raise its <em>New Data Available</em> event, as well as to return TRUE when its <a class="el" href="classxn_1_1_module_generator.html#a15485d6f869ea1a807c256b80cba1873">xn::ModuleGenerator::IsNewDataAvailable()</a> method is called.</p>
<p>The event is used by OpenNI to check current state if the application called one of the WaitXUpdateAll methods. In those methods, OpenNI waits for some new data to arrive and then checks if the requested condition was completed. If so, it updates all the nodes which has new data. It uses the <a class="el" href="classxn_1_1_module_generator.html#a15485d6f869ea1a807c256b80cba1873">xn::ModuleGenerator::IsNewDataAvailable()</a> method for checking if the node has new data, and the <a class="el" href="classxn_1_1_module_generator.html#a543e11766a86916c78d7065d0f4bb4a8">xn::ModuleGenerator::UpdateData()</a> to make the node update its data. The <em>UpdateData</em> method is the only place where the node implementation is allowed to modify its last updated data.</p>
<h2><a class="anchor" id="modules_gen_active"></a>
Example A: An Active Generator</h2>
<p>An active generator is a generator that does its generation in a thread other than the application thread.</p>
<p>Usually, its implementation will be as follows:</p>
<ul>
<li>The StartGenerating() method starts a worker thread (or perform an asynchronous call) that is responsible of getting new data.</li>
<li>The StopGenerating() method stops the worker thread (or cancels the asynchronous call).</li>
<li>The node holds a buffer containing the last updated data (i.e. the "user" buffer, the buffer holding the data the application received after last UpdateData() method was called).</li>
<li>When the worker thread is done generating the new data (or the asynchronous call has returned), the data is stored in another buffer (the "next" buffer), and the <em>New Data Available</em> event is raised.</li>
<li>The IsNewDataAvailable() methods checks if the "next" buffer exists.</li>
<li>The UpdateData() method changes the "next" buffer to be the "user" buffer, and deletes the previous "user" buffer.</li>
</ul>
<p>Of course, the explanation above is simplified. Usually, instead of allocating and deleting data buffers, a buffer pool is used, and the implementation should copy the data from one buffer to the other as little as possible, so that it wouldn't consume much hardware resources.</p>
<h2><a class="anchor" id="modules_gen_passive"></a>
Example B: A Passive Generator</h2>
<p>A passive generator usually depends on the data of another generator. It does some processing in the application thread to produce new data from its input node's data.</p>
<p>Usually, its implementation will be as follows:</p>
<ul>
<li>The StartGenerating() method registers to its input node <em>New Data Available</em> event.</li>
<li>The StopGenerating() method unregisters from this event.</li>
<li>The node holds a buffer containing the last updated data (i.e. the "user" buffer, the buffer holding the data the application received after last UpdateData() method was called).</li>
<li>When the input node's <em>New Data Available</em> event is raised, it raises its own event, also marking that new input data is available for processing (using a member flag).</li>
<li>The IsNewDataAvailable() method checks if this flag is turned on. <b>Note:</b> it is not sufficient to check if the input node has new data available, because this method might be called <b>after</b> the input node's UpdateData() method was called, but before our node's UpdateData() method was called. In such a case, the input node will say it has no new data, but its last data wasn't processed yet by our node.</li>
<li>The UpdateData() method takes the input data from the input node, does some processing and updates the "user" buffer. </li>
</ul>
</div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="main.html">OpenNI Documentation</a>      </li>
      <li class="navelem"><a class="el" href="modules_root.html">Creating OpenNI Modules</a>      </li>
      <li class="navelem"><a class="el" href="modules_node.html">Creating a Node Implementation</a>      </li>
      <li class="footer">Generated on Wed Nov 16 2011 15:09:49 for OpenNI 1.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
