<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.4.0: Creating a Node Exporter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('modules_exporter.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>Creating a Node Exporter </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Once we completed our node implementation class, we should create a node exporter class to export our new node to OpenNI. The node exporter is some sort of a factory. It allows getting some information about this node implementation, it supports enumerating which instances of this implementation can be created at the moment, and allows creating such instances and destroying them.</p>
<p>Creating a node exporter is done by defining a new class inheriting from <a class="el" href="classxn_1_1_module_exported_production_node.html">xn::ModuleExportedProductionNode</a>.</p>
<h2><a class="anchor" id="modules_exporter_desc"></a>
Node Description</h2>
<p>Each node implementation has a description. The description contains the following information:</p>
<ul>
<li>Node Type (Depth Generator / Device / Hands Generator, etc.)</li>
<li>Vendor Name</li>
<li>Produce Name (To distinguish two products from the same vendor)</li>
<li>Version</li>
</ul>
<p>This description should be unique to each node implementation.</p>
<h2><a class="anchor" id="modules_exporter_enum"></a>
Enumeration</h2>
<p>The enumeration process is where production graphs are created. When an application asks for a node of a specific type, OpenNI enumerates the node exporters which declared this type. The node exporter is responsible of returning the list of production graphs that can be created in order to have such a node. Of course, each such production graph will have our node implementation as its root.</p>
<p>The enumeration process is the opportunity to:</p>
<ul>
<li>Check if a specific hardware is attached and ready for operation. For example, an exporter of a device node will usually query the operating system to find our if a specific USB device is connected right now. It can also check if this hardware is not already in use by another software, and so cannot be used. If more than one device is connected, it can return two different production graphs, one for each such device.</li>
<li>Check that a valid license exists to use the node implementation.</li>
<li>Enumerate nodes from another type that are required for this node implementation to function.</li>
</ul>
<p>A production graph alternative is represented by a <a class="el" href="classxn_1_1_node_info.html">xn::NodeInfo</a> object. It contains a description of the node (must be the same as the description returned by the <a class="el" href="classxn_1_1_module_exported_production_node.html#ad6f40b95e7b8efddb338e7c4088ce9bd">xn::ModuleExportedProductionNode::GetDescription()</a> method), an optional creation info and a list of depended nodes (through which the entire graph can be described).</p>
<p>Adding production graphs to the list is usually done using the <a class="el" href="classxn_1_1_node_info_list.html#a3df77553f1089ac85470615c66c62a20">xn::NodeInfoList::Add()</a> method.</p>
<p>Note that one of the returned production graph alternatives might be used later on to create the production graph, so it's important that this alternative will fully describe the exact instance to be created. If two alternatives only differ in the way the root node (our node implementation) is created, the difference can be described in the <em>creation info</em> member.</p>
<p>If the node implementation depends on exactly one input node, it can use the <a class="el" href="classxn_1_1_context.html#adbac4aa85e6f9b0820925cc5e6d763bd">xn::Context::AutoEnumerateOverSingleInput()</a> utility method.</p>
<p>If no production graphs alternatives are currently available, besides returning an empty list, it is also advised to return a return value other than XN_STATUS_OK. This return value will be added to the EnumerationErrors object, so that the application can later on check why a specific node failed to enumerate.</p>
<p><b>Note:</b> Current OpenNI interface can not pass state while enumerating. This causes a problem if production graph cycles might occur (for example, if a depth generator enumerates for depth generator, or if a hands generator enumerates for user generator which itself enumerates for hands generator). Right now, the best solution is to use a static boolean inside your Enumerate() implementation, to recognize if the method is called recursively, and if so, return nothing.</p>
<h2><a class="anchor" id="modules_exporter_create"></a>
Creating the Node</h2>
<p>Once enumeration is complete, the application can choose one of the returned production graphs alternatives and ask OpenNI to create it. OpenNI assures the node exporter that all needed nodes in the production graphs will be created before calling to <a class="el" href="classxn_1_1_module_exported_production_node.html#ae8344d27f82e2b7da3b5dee16294795d">xn::ModuleExportedProductionNode::Create()</a>, so that the exporter can take those nodes and use them. In addition to the information found in the NodeInfo object (needed nodes, creation info), OpenNI passes to the exporter an instance name (the name that this node will have in OpenNI context), and a configuration dir (taken from the module registration. see <a class="el" href="modules_registration.html">Registering the new Module</a>).</p>
<p>The exporter should create the node implementation it exports, and return a pointer to it to OpenNI.</p>
<h2><a class="anchor" id="modules_exporter_destroy"></a>
Destroying the Node</h2>
<p>Once OpenNI determines that the node is no longer needed, it will ask the exporter to destroy it by calling <a class="el" href="classxn_1_1_module_exported_production_node.html#aacdbd675bb6cd1a31a5e9c20e8c6e7c9">xn::ModuleExportedProductionNode::Destroy()</a>.</p>
<h2><a class="anchor" id="modules_exporter_ex1"></a>
Example A: Exporter for a node which requires a physical device</h2>
<p>Let's take for example a device node which represent some USB physical device. The enumeration uses the operating system to find out which devices are connected right now, takes the path to each of them, and create a production graph for each. The exporter places the device path in the creation info, so it would know the right device to connect to.</p>
<p>The Create() method takes the creation info and passes it to the device node constructor.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyDevice : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleDevice
{
<span class="keyword">public</span>:
    MyDevice(<span class="keyword">const</span> XnChar* strDevicePath);
    ...
};

<span class="keyword">class </span>MyDeviceExporter : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleExportedProductionNode
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> GetDescription(<a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a>* pDescription) 
    {
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a9499efe08226548c89a6684534f0d769">Type</a> = <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a3f3f170232645dd79fdbe7f7cc4e2097">XN_NODE_TYPE_DEVICE</a>;
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a6b1d091887c8391c974e4ec6c8f2bf48">strVendor</a>, <span class="stringliteral">&quot;New Devices Inc.&quot;</span>);
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#ac65ad15c1d36fe884068b210f0ad3f4e">strName</a>, <span class="stringliteral">&quot;MyDevice&quot;</span>);
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a472efc887378bca0cbe490e30b6f80f7">nMajor</a> = 1;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a03d37d89a944305571c8681eed15058a">nMinor</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#aa3c800490a6d99f038faca0fc6626576">nMaintenance</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#adead3f3f47c9e3dbdc766cad1574a19e">nBuild</a> = 7;
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> EnumerateProductionTrees(Context&amp; context, NodeInfoList&amp; TreesList, EnumerationErrors* pErrors) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;

        <a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> description;
        GetDescription(&amp;description);
        
        <span class="comment">// find which USB device are connected</span>
        <span class="keyword">const</span> <a class="code" href="_xn_u_s_b_8h.html#a9529e5f3d9ae6e4126e5b42a76e69161">XnUSBConnectionString</a>* astrDevicePaths;
        XnUInt32 nCount;

        nRetVal = <a class="code" href="_xn_u_s_b_8h.html#ac5fb02ceb74da39b14561d45f8ad571b">xnUSBEnumerateDevices</a>(MY_VENDOR_ID, MY_PRODUCT_ID, astrDevicePaths, &amp;nCount);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);
        
        <span class="keywordflow">if</span> (nCount == 0)
        {
            <span class="comment">// no device was found. return an error</span>
            <span class="keywordflow">return</span> XN_STATUS_DEVICE_NOT_CONNECTED;
        }

        <span class="comment">// add a production graph alternative for each connected device</span>
        <span class="keywordflow">for</span> (XnUInt32 i = 0; i &lt; nCount; ++i)
        {
            nRetVal = TreesList.Add(description, astrDevicePaths[i], NULL);
            <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);
        }

        <a class="code" href="_xn_u_s_b_8h.html#a0ec4128ee87d55dbf470c6de20ae95c4">xnUSBFreeDevicesList</a>(astrDevicePaths);

        <span class="keywordflow">return</span> (<a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>);
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Create(Context&amp; context, <span class="keyword">const</span> XnChar* strInstanceName, <span class="keyword">const</span> XnChar* strCreationInfo, 
                            NodeInfoList* pNeededTrees, <span class="keyword">const</span> XnChar* strConfigurationDir, ModuleProductionNode** ppInstance) 
    {
        *ppInstance = <span class="keyword">new</span> MyDevice(strCreationInfo);
        <span class="keywordflow">if</span> (*ppInstance == NULL)
        {
            <span class="keywordflow">return</span> XN_STATUS_ALLOC_FAILED;
        }

        <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Destroy(ModuleProductionNode* pInstance) 
    {
        <span class="keyword">delete</span> pInstance;
    }
};
</pre></div><h2><a class="anchor" id="modules_exporter_ex2"></a>
Example B: Exporter for a node which requires one input node</h2>
<p>Let's take for example a hands generator that works on an RGB image. The exporter will declare the node needs an image generator as input.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyHandsGenerator : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleHandsGenerator
{
<span class="keyword">public</span>:
    MyHandsGenerator(ImageGenerator imageGen);
    ...
};

<span class="keyword">class </span>MyHandsExporter : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleExportedProductionNode
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> GetDescription(<a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a>* pDescription) 
    {
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a9499efe08226548c89a6684534f0d769">Type</a> = <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a3f3f170232645dd79fdbe7f7cc4e2097">XN_NODE_TYPE_DEVICE</a>;
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a6b1d091887c8391c974e4ec6c8f2bf48">strVendor</a>, <span class="stringliteral">&quot;New Algorithms Inc.&quot;</span>);
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#ac65ad15c1d36fe884068b210f0ad3f4e">strName</a>, <span class="stringliteral">&quot;MyHandsGenerator&quot;</span>);
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a472efc887378bca0cbe490e30b6f80f7">nMajor</a> = 1;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a03d37d89a944305571c8681eed15058a">nMinor</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#aa3c800490a6d99f038faca0fc6626576">nMaintenance</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#adead3f3f47c9e3dbdc766cad1574a19e">nBuild</a> = 7;
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> EnumerateProductionTrees(Context&amp; context, NodeInfoList&amp; TreesList, EnumerationErrors* pErrors) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;

        <a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> description;
        GetDescription(&amp;description);

        <span class="keywordflow">return</span> context.AutoEnumerateOverSingleInput(
            TreesList,          <span class="comment">// the list to be filled</span>
            description,        <span class="comment">// our description</span>
            NULL,               <span class="comment">// creation info. Not needed in this example.</span>
            <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a>, <span class="comment">// type of the single input required</span>
            pErrors,            <span class="comment">// the EnumerationErrors object</span>
            NULL                <span class="comment">// query. Not needed in this example.</span>
            );
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Create(Context&amp; context, <span class="keyword">const</span> XnChar* strInstanceName, <span class="keyword">const</span> XnChar* strCreationInfo, 
                            NodeInfoList* pNeededTrees, <span class="keyword">const</span> XnChar* strConfigurationDir, ModuleProductionNode** ppInstance) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
        
        <span class="comment">// take the first needed node</span>
        NodeInfoList::Iterator it = pNeededTrees-&gt;Begin();
        <span class="keywordflow">if</span> (it == pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        NodeInfo imageInfo = *it;

        <span class="comment">// make sure its of the right type and that this is the only one</span>
        <span class="keywordflow">if</span> (imageInfo.GetDescription().Type != <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a> || ++it != pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        <span class="comment">// OpenNI assures us the image node is already created</span>
        ImageGenerator image;
        nRetVal = imageInfo.GetInstance(image);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        *ppInstance = <span class="keyword">new</span> MyHandsGenerator(image);
        <span class="keywordflow">if</span> (*ppInstance == NULL)
        {
            <span class="keywordflow">return</span> XN_STATUS_ALLOC_FAILED;
        }

        <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Destroy(ModuleProductionNode* pInstance) 
    {
        <span class="keyword">delete</span> pInstance;
    }
};
</pre></div><h2><a class="anchor" id="modules_exporter_ex3"></a>
Example C: Exporter for a node which requires two different nodes</h2>
<p>Let's take for example a hands generator that needs both RGB information and depth information of the scene. The exporter will create production graphs alternatives that require both ImageGenerator and DepthGenerator.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyHandsGenerator : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleHandsGenerator
{
<span class="keyword">public</span>:
    MyHandsGenerator(ImageGenerator&amp; imageGen, DepthGenerator&amp; depthGen);
    ...
};

<span class="keyword">class </span>MyHandsExporter : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleExportedProductionNode
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> GetDescription(<a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a>* pDescription) 
    {
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a9499efe08226548c89a6684534f0d769">Type</a> = <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a3f3f170232645dd79fdbe7f7cc4e2097">XN_NODE_TYPE_DEVICE</a>;
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a6b1d091887c8391c974e4ec6c8f2bf48">strVendor</a>, <span class="stringliteral">&quot;New Algorithms Inc.&quot;</span>);
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#ac65ad15c1d36fe884068b210f0ad3f4e">strName</a>, <span class="stringliteral">&quot;MyHandsGenerator&quot;</span>);
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a472efc887378bca0cbe490e30b6f80f7">nMajor</a> = 1;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a03d37d89a944305571c8681eed15058a">nMinor</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#aa3c800490a6d99f038faca0fc6626576">nMaintenance</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#adead3f3f47c9e3dbdc766cad1574a19e">nBuild</a> = 7;
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> EnumerateProductionTrees(Context&amp; context, NodeInfoList&amp; TreesList, EnumerationErrors* pErrors) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;

        <a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> description;
        GetDescription(&amp;description);

        <span class="comment">// find production graph alternatives for image</span>
        NodeInfoList imageList;
        nRetVal = context.EnumerateProductionTrees(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a>, NULL, imageList, pErrors);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        <span class="comment">// find production graph alternatives for depth</span>
        NodeInfoList depthList;
        nRetVal = context.EnumerateProductionTrees(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, NULL, depthList, pErrors);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        <span class="comment">// now for each combination, we create one alternative</span>
        <span class="keywordflow">for</span> (NodeInfoList::Iterator imageIt = imageList.Begin(); imageIt != imageList.End(); ++imageIt)
        {
            <span class="keywordflow">for</span> (NodeInfoList::Iterator depthIt = depthList.Begin(); depthIt != depthList.End(); ++depthIt)
            {
                <span class="comment">// create needed nodes list</span>
                NodeInfoList neededNodes;

                nRetVal = neededNodes.AddNodeFromAnotherList(imageIt);
                <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

                nRetVal = neededNodes.AddNodeFromAnotherList(depthIt);
                <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

                nRetVal = TreesList.Add(
                    description,    <span class="comment">// our description</span>
                    NULL,           <span class="comment">// creation info. not needed in this example</span>
                    &amp;neededNodes    <span class="comment">// needed nodes list</span>
                    );
                <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);
            }
        }

        <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Create(Context&amp; context, <span class="keyword">const</span> XnChar* strInstanceName, <span class="keyword">const</span> XnChar* strCreationInfo, 
                            NodeInfoList* pNeededTrees, <span class="keyword">const</span> XnChar* strConfigurationDir, ModuleProductionNode** ppInstance) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
        
        <span class="comment">// take the first needed node</span>
        NodeInfoList::Iterator it = pNeededTrees-&gt;Begin();
        <span class="keywordflow">if</span> (it == pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        NodeInfo imageInfo = *it;

        <span class="comment">// take the second needed node</span>
        ++it;
        <span class="keywordflow">if</span> (it == pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        NodeInfo depthInfo = *it;

        <span class="comment">// make sure types are correct and that no more nodes were received</span>
        <span class="keywordflow">if</span> (imageInfo.GetDescription().Type != <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a> || 
            depthInfo.GetDescription().Type != <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a> ||
            ++it != pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        <span class="comment">// OpenNI assures us the nodes are already created</span>
        ImageGenerator image;
        nRetVal = imageInfo.GetInstance(image);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        DepthGenerator depth;
        nRetVal = depthInfo.GetInstance(depth);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        *ppInstance = <span class="keyword">new</span> MyHandsGenerator(image, depth);
        <span class="keywordflow">if</span> (*ppInstance == NULL)
        {
            <span class="keywordflow">return</span> XN_STATUS_ALLOC_FAILED;
        }

        <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Destroy(ModuleProductionNode* pInstance) 
    {
        <span class="keyword">delete</span> pInstance;
    }
};
</pre></div> </div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="main.html">OpenNI Documentation</a>      </li>
      <li class="navelem"><a class="el" href="modules_root.html">Creating OpenNI Modules</a>      </li>
      <li class="footer">Generated on Wed Nov 16 2011 15:09:49 for OpenNI 1.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
